//--------------------------------------------------------------------
//
// File Name: AudioSignal.h
// Author: Xi Chen
// Email Address: chenx19@miamioh.edu
// Description: AudioSinal class that provides a convenient interface to 
// manipulate audio signals. The AudioSignal class encapsulates 
// information about a digital audio signal that has been sampled using 
// Linear Pulse Code Modulation (LPCM). An audio signal is essentially a 
// series of Sample (alias for 16-bit integers defined in RIFF.h) entries.  
// Example: {0, 10, 15, 10, 0, -10, -15, -10, 0} where each value in the 
// list is of data type Sample.  In addition to the actual data, each audio 
// signal also contains the following metadata associated with the signal:
// sampleRate and bitsPerSample
//
// Last Changed: February 13, 2013
//
//---------------------------------------------------------------------


#ifndef AUDIOSIGNAL_H
#define AUDIOSIGNAL_H

#include <iostream>
#include <vector>

#include "RIFF.h"
//#include "NoteMaker.h"

class AudioSignal {
 private:
    /**
       Number of samples per second
    */
    int sampleRate; 

    /**
       Bits per sample. Can be 8-bits or 16-bits
    */
    short bitsPerSample;   

    /**
       The actual data for this audio signal
     */ 
    std::vector<Sample> wave; 

 public:
    /**
       Constructor to create a audio signal with a given sample rate and
       bits per sample. This constructor creates an audio signal that 
       does not have any wave (or actual sound data) associated with it.
       It merely initializes the appropriate instance variables with 
       suitable values.  
    */
    AudioSignal(const int sampleRate = 22050, const short bitsPerSample = 16);
    
    /**
       Constructor to create a audio signal from a given RIFF file.
       This constructor creates an audio signal by loading all the 
       necessary information for various instance variables from a 
       given ".wav"/RIFF file (inputWaveFile).

       Note: Do not use istream_iterator to read data. Instead, use s
       tandard while loop as shown in RIFFReader API documentation. 
     */
    AudioSignal(RIFFReader& inputWaveFile);

    /**
       A standard copy constructor
     */
    AudioSignal(const AudioSignal& src);

    /**
       A standard move constructor.
    */
    AudioSignal(AudioSignal&& src);

    /**
       A standard assignment operator 
     */
    AudioSignal& operator=(const AudioSignal& src);

    /**
       This constructor creates a sinusoidal audio signal of the given 
       frequency, maximum amplitude, sample rate, and bits per sample.  The 
       freq parameter defines the frequency of the audio signal to be 
       generated by this method while the lenInMills parameter defines the 
       duration of the audio signal in milliseconds.  For example, if the 
       frequency is 10 Hz and the lenInMills is 1000 (one second long) then 
       this method generates 10 full sine waves in the given samples. The 
       amplitude parameter defines the maximum amplitude of the signal. 
       The sampleRate parameter indicates the sampling rate for the audio 
       signal. The sampling rate indicates the number of samples for each 
       second of this audio signal. The bitsPerSample indicates the number 
       of bits occupied by each entry in the audio wave associated with this 
       signal. This value must be either 8 or 16. If the decay parameter is 
       true then the amplitude of the audio signal is exponentially decayed 
       to simulate striking of real musical string instrument per the 
       following formula :

       exp((double) -i / SampleCount / 0.5)

       where i is the zero-based index of the sample.

       Note: For this constructor it is best to write routine loops rather 
       than using algorithms
     */
    AudioSignal(const int freq, const int lenInMills, const int amplitude, 
		const int sampleRate = 22050, const short bitsPerSample = 16, 
		const bool decay = true); 

    /**
       This method is used to superposition this audio signal with other audio
       signal to create and return a new audio signal. For example if this 
       audio signal has wave data {1, 2, 3} and the other audio signal has 
       wave data {4, -2, 6, 100, -100} the resulting audio stream has the 
       data {7, 0, 9, 100, -100} obtained by simply adding corresponding 
       values in two signal).    This method assumes that the two signals 
       have the same sample rate but the signals can be of different lengths. 
       The resulting audio signal returned by this method is the same duration
       of the longer of the two signals.

       This method returns a new audio signal (neither this nor other is 
       modified) that is a constructive superposition of the two given audio 
       signals.
     */
    AudioSignal operator+(const AudioSignal& other) const;

    /**
       Method to concatenate another audio signal onto this signal.  This 
       method provides implementation for the ampersand operator to append 
       another signal to the end of this signal.  For  example if this audio 
       signal has wave data {1, 2, 3} and the other audio signal has wave 
       data {100, 200, 300}, then this method converts this to 
       {1, 2, 3, 100, 200, 300}.

       This method returns a reference to this signal  
     */
    AudioSignal& operator&(const AudioSignal& other);

    /**
       Amplify/reduce (or scale) each sample in this signal by the given 
       factor. This method is used to suitably scale each sample in the given 
       audio scale. For example if this audio signal has wave data
       {2, -4, 6, â€¦} and the scale factor is 2.0 then samples in this wave s
       hould be modified to {4, -8, 12, ....}. The method modifies this 
       object and does not create a new object.
                
       If the factor is greater than 1 then the signal is amplified (volume 
       increases).  If the factor is less than 1 then the signal is reduced 
       (volume decreases).

       This method returns a reference to this object. 
     */
    AudioSignal& operator*(const double factor);

    /**
       Shift the audio signal to the right by the given amount of time (in 
       milliseconds).

       This method shifts the audio signal by the necessary number of samples
       (given the sampling rate and the timeInMillis) by inserting zeros at 
       the beginning of the wave.  For example if this audio signal has wave 
       data {5, -17, 25, 3, ....} then shifting it to the right by 1 
       millisecond (assuming it results in requiring to add 5 samples) results
       in a new audio signal with the wave data {0, 0, 0, 0, 0, 5, -17, 25, 3,
       ...}. Note that this operator does not modify this object. The number 
       of zeros to be inserted must be computed based on the samplingRate of 
       the audio signal.  
     */
    AudioSignal operator>>(long timeInMillis) const;

    /**
       Shift the audio signal to the left by the given amount of time (in 
       milliseconds).

       This method shifts the audio signal by the necessary number of samples 
       (given the sampling rate and the timeInMillis) by removing samples at 
       the beginning of the wave.  For example if this audio signal has wave 
       data {5, -17, 25, 3, -9, 0, 15, ....} then shifting it to the left by 
       1 millisecond (assuming it results in requiring to remove 5 samples) 
       results in a new audio signal with the wave data {0, 15, ...}. Note 
       that this operator does not modify this object. The number of samples 
       to be removed must be computed based on the samplingRate of the audio 
       signal.  
     */
    AudioSignal operator<<(long timeInMillis) const;

    /**
       Returns the duration of this audio signal in milliseconds (determined 
       using number of entries in wave and the sampleRate) 
     */
    long duration() const;

    /**
       Write the audio data in this signal to a given fileName using a 
       RIFFWriter object. This method must create a suitable RIFFWriter 
       stream and write the audio data in this signal to the file.

       Note:  Do not use a ostream_iterator.  Use a for-each loop to write 
       the data to a RIFFWriter. The method is not expected to throw exception
       but just exposes the exceptions that may be generated by the various 
       methods called by the method. 
     */
    void write(const std::string& fileName) const throw (std::exception);

    /**
       Increase or decrease the duration of this audio signal to the given 
       duration of time.

       This method changes this audio signal such that the duration of the 
       signal is changed to the specified timeInMills value, which indicates 
       the desired duration of the signal in milliseconds.

       This method must modify the duration of the signal in the one of the 
       following two ways:
        
       1.	If the current signal is shorter than the specified duration, 
       then the current signal is replicated (or repeated)  until the desired 
       duration of samples is obtained.

       2.	If the current signal is longer than the specified duration 
       then the signal is truncated (by simply discarding samples at the end 
       of the signal) to the necessary duration. 
     */
    void changeDurationTo(const int timeInMillis);

    /**
       for test only
       print all the information of AudioSignal
     */
    //void print();
};
       

#endif
